---
title: "Mislabel Simulation"
author: "Ryan C. Thompson"
output: html_notebook
---

```{r}

## Small TODOs:

# 1. Run corrections with a seed
# 2. Change relabel functions to swap labels and not whatever it is that I'm doing right now
# 3. Need some indication that inferred swaps are less certain than original labels, 
#    especially for correct_majority_swaps
# 4. Create a connected component object

```

# Load packages

```{r message=FALSE, warning=FALSE}

library(rlang)
is_named <- rlang::is_named
library(withr)
library(methods)
library(fs)
library(qs)
library(dplyr)
filter <- dplyr::filter
select <- dplyr::select
rename <- dplyr::rename
matches <- dplyr::matches
mutate <- dplyr::mutate
desc <- dplyr::desc
library(tidyr) 
library(magrittr)
subtract <- magrittr::subtract
library(stringr)
library(glue)
library(rex)
library(igraph)
as_data_frame <- igraph::as_data_frame
library(assertthat)
library(rctutils)
library(variancePartition)
library(ggplot2)
library(pROC)
library(scales)
library(colorspace)
library(patchwork)
library(forcats)
library(entropy)
library(limma)
library(progress)
library(statmod)
library(qvalue)
library(S4Vectors)
library(BiocParallel)
library(parallel)
library(future)
library(future.apply)
library(future.callr)
library(combinat)
library(tibble)
column_to_rownames <- tibble::column_to_rownames
rownames_to_column <- tibble::rownames_to_column

plan(callr)

# Makes EList and MArrayLM objects print nicely, for convenience
try(source("prettylimma.R"), silent = TRUE)

```

# General helpers

```{r}

reorder_elist_samples <- function(elist, sample_ids) {
    if (all(sample_ids == elist$targets$E_Sample_ID)) {
        return(elist)
    }
    
    assert_that(length(sample_ids) == dim(elist)[[2]], 
                msg = glue("sample_ids param length {length(sample_ids)} does not match elist sample dimension {dim(elist)[[2]]}"))
    
    reordered_elist <- elist
    reordered_elist$E <- elist$origs$E_true[, sample_ids]
    colnames(reordered_elist) <- colnames(elist)
    reordered_elist$targets %<>% mutate(
        E_Sample_ID = sample_ids,
        E_Subject_ID = str_extract(sample_ids, rex(start, not("_"))),
        ## this is hacky, will fix this when we swap labels instead of whatever it is I'm doing now
        Genotype_Group_ID = str_c("Genotype_Group", as.character(as.numeric(factor(E_Subject_ID)))),
        Mislabeled = !(Sample_ID == E_Sample_ID),
        Mislabeled_Subject = !(Subject_ID == E_Subject_ID)
    )
    return(reordered_elist)
}

swap_elist_samples <- function(elist, swaps) {
    if (nrow(swaps) == 0) {return(elist)}
    
    unexpected_samples <- setdiff(unique(unlist(swaps)), elist$targets$Sample_ID)
    assert_that(length(unexpected_samples) == 0, 
                msg = glue("Cannot swap samples {unexpected_samples} that aren't part of Sample_ID set"))
    
    sample_ids <- elist$targets$E_Sample_ID
    for (row in 1:nrow(swaps)) {
        index1 <- match(swaps[row, 1], elist$targets$Sample_ID)
        index2 <- match(swaps[row, 2], elist$targets$Sample_ID)
        sample1 <- sample_ids[[index1]]
        sample2 <- sample_ids[[index2]]
        sample_ids[[index1]] = sample2
        sample_ids[[index2]] = sample1
    }
    return(reorder_elist_samples(elist, sample_ids))
}

relabel_elist_samples <- function(elist, relabels) {
    if (nrow(relabels) == 0) {return(elist)}
    
    unexpected_samples <- setdiff(unique(unlist(relabels)), elist$targets$Sample_ID)
    assert_that(length(unexpected_samples) == 0, 
                msg = glue("Cannot swap samples {unexpected_samples} that aren't part of Sample_ID set"))
    assert_that(
        anyDuplicated(relabels[[1]]) == 0,
        anyDuplicated(relabels[[2]]) == 0,
        msg = "Non-unique sample_id found in different rows of relabels dataframe"
    )
    assert_that(setequal(relabels[[1]], relabels[[2]]),
        msg = "relabel_from and relabel_to columns in relabels dataframe contain different elements"
    )
    
    ## I hate the way I'm doing this
    rownames(relabels) <- relabels[[2]]
    reindex <- elist$targets %>% 
        select(Sample_ID, E_Sample_ID) %>% 
        mutate(
            Relabel_Sample_ID = sapply(Sample_ID, \(x) relabels[x, 1]),
            Relabel_Sample_ID = ifelse(is.na(Relabel_Sample_ID), Sample_ID, Relabel_Sample_ID)
        ) %>% pull(Relabel_Sample_ID)
    sample_ids <- elist$targets[reindex, "E_Sample_ID"]

    return(reorder_elist_samples(elist, sample_ids))
}

digits <- function(x, base = 10) {
    1 + floor(log(x, base = base))
}

generate_ids <- function(prefix, n, num_digits=digits(max(n))) {
    if (length(n) == 1) {
        n <- seq_len(n)
    }
    digit_format <- str_c("%0", num_digits, "i")
    str_c(prefix, sprintf(digit_format, n))
}

## The SVD-based check crashes with Lapack errors sometimes
## design_is_identifiable <- function(dmat, eps = 2e-16) {
##     min(svd(dmat)$d) > eps
## }
design_is_identifiable <- function(dmat, ...) {
    qrd <- qr(x = dmat, ...)
    qrd$rank == ncol(dmat)
}

coolcat_no_filter <-function (fmt, vals = character(), exdent = 2, ...)
{
    lbls <- paste(S4Vectors:::selectSome(vals), collapse = " ")
    txt <- sprintf(fmt, length(vals), lbls)
    cat(strwrap(txt, exdent = exdent, ...), sep = "\n")
}

show_EList <- function (object) {
    cat("class:", class(object), "\n")
    cat("dim:", dim(object), "\n")
    rownames <- rownames(object)
    if (!is.null(rownames))
        coolcat("rownames (%d): %s\n", rownames)
    else cat("rownames: NULL\n")
    coolcat("genes table names (%d): %s\n", names(object$genes))
    colnames <- colnames(object)
    if (!is.null(colnames))
        coolcat("colnames(%d): %s\n", colnames)
    else cat("colnames: NULL\n")
    coolcat("targets table names (%d): %s\n", names(object$targets))
    coolcat_no_filter("E (%d): %s\n", as.vector(object$E))
    if (!is.null(object$weights))
        coolcat_no_filter("weights (%d): %s\n", as.vector(object$weights))
    other_names <- setdiff(names(object), c("E", "weights", "targets", "genes"))
    if (length(other_names) > 0)
        coolcat("Other elements (%d): %s\n", other_names)
    other_slot_names <- setdiff(slotNames(object), ".Data")
    if (length(other_slot_names) > 0)
        coolcat("Other slots (%d):  %s\n", other_slot_names)
}

```

# Mislabel solving algorithm

## Common helpers

```{r}

validate_sample_genotype_data <- function(sample_genotype_data, init_required=FALSE) {
    assert_that(
        is.data.frame(sample_genotype_data),
        msg = "Invalid: 'sample_genotype_data' must be a data frame"
    )
    
    required_columns <- c("Sample_ID", "Subject_ID", "Genotype_Group_ID")
    if (init_required) required_columns <- c(required_columns, c("Init_Sample_ID"))
    missing_columns <- setdiff(required_columns, names(sample_genotype_data))
    assert_that(
        length(missing_columns) == 0,
        msg = glue("Invalid: 'sample_genotype_data' is missing required column(s) {paste(missing_columns, collapse=\", \")}")
    )
       
    duplicated_samples <- sample_genotype_data$Sample_ID[duplicated(sample_genotype_data$Sample_ID)]
    assert_that(
        length(duplicated_samples) == 0,
        msg = glue("Invalid: 'sample_genotype_data' has non-unique Sample_ID(s) {paste(duplicated_samples, collapse=\", \")}")
    )
}

validate_putative_subjects <- function(putative_subjects) {
    assert_that(
        is.data.frame(putative_subjects),
        msg = "Invalid: 'putative_subjects' must be a data frame"
    )
    
    required_columns <- c("Subject_ID", "Genotype_Group_ID")
    missing_columns <- setdiff(required_columns, names(putative_subjects))
    assert_that(
        length(missing_columns) == 0,
        msg = glue("Invalid: 'putative_subjects' is missing required column(s) {paste(missing_columns, collapse=\", \")}")
    )
    
    duplicated_subjects <- putative_subjects$Subject_ID[duplicated(putative_subjects$Subject_ID)]
    assert_that(
        length(duplicated_subjects) == 0,
        msg = glue("Invalid: 'putative_subjects' does not map Subject_ID to Genotype_Group_ID one-to-one, check Subject_ID(s) {paste(duplicated_samples, collapse=\", \")}")
    )
    duplicated_genotype_groups <- putative_subjects$Genotype_Group_ID[duplicated(putative_subjects$Genotype_Group_ID)]
    assert_that(
        length(duplicated_genotype_groups) == 0,
        msg = glue("Invalid: 'putative_subjects' does not map Subject_ID to Genotype_Group_ID one-to-one, check Genotype_Group(s) {paste(duplicated_genotype_groups, collapse=\", \")}")
    )
}

validate_relabels <- function(sample_genotype_data, relabels) {
    validate_sample_genotype_data(sample_genotype_data)
    
    assert_that(
        is.data.frame(relabels),
        msg = "Invalid: 'relabels' must be a data frame"
    )
    
    required_columns <- c("relabel_from", "relabel_to")
    missing_columns <- setdiff(required_columns, names(relabels))
    assert_that(
        length(missing_columns) == 0,
        msg = glue("Invalid: 'relabels' is missing required column(s) {paste(missing_columns, collapse=\", \")}")
    )
    
    missing_relabel_from <- setdiff(relabels$relabel_from, sample_genotype_data$Sample_ID)
    assert_that(
        length(missing_relabel_from) == 0,
        msg = glue("Invalid: 'relabels$relabel_from' has Sample_ID(s) not in 'sample_genotype_data', check {paste(missing_relabel_from, collapse=\", \")}")
    )
    missing_relabel_to <- setdiff(relabels$relabel_to, sample_genotype_data$Sample_ID)
    assert_that(
        length(missing_relabel_to) == 0,
        msg = glue("Invalid: 'relabels$relabel_to' has Sample_ID(s) not in 'sample_genotype_data', check {paste(missing_relabel_to, collapse=\", \")}")
    )
    
    duplicated_relabel_from <- relabels$relabel_from[duplicated(relabels$relabel_from)]
    assert_that(
        length(duplicated_relabel_from) == 0,
        msg = glue("Invalid: 'relabels$relabel_from' has non-unique Sample_ID(s), check Sample_ID(s) {paste(duplicated_relabel_from, collapse=\", \")}")
    )
    duplicated_relabel_to <- relabels$relabel_to[duplicated(relabels$relabel_to)]
    assert_that(
        length(duplicated_relabel_to) == 0,
        msg = glue("Invalid: 'relabels$relabel_to' has non-unique Sample_ID(s), check Sample_ID(s) {paste(duplicated_genotype_groups, collapse=\", \")}")
    )
}

plot_graph <- function(graph) {
    edge_colors <- if (!is.null(E(graph)$edge_colors)) E(graph)$edge_colors else "grey"
    vertex_colors <- if (!is.null(V(graph)$vertex_colors)) V(graph)$vertex_colors else "orange"
    layout_custom <- with_seed(layout_nicely(graph), seed=1987)
    my_plot <- plot(graph, vertex.size=3, vertex.label.cex=0.6, edge.arrow.size=.8, 
                       edge.color=edge_colors, vertex.color=vertex_colors, vertex.label.color="black", 
                       vertex.frame.color="transparent", layout=layout_custom)
    print(my_plot)
}

graph_type_mapping <- list(
    label = "Subject_ID",
    genotype = "Genotype_Group_ID",
    combined = NA_character_
)
## param 'filter_components' removes solved components (any component where all edges are concordant)
generate_graph = function(sample_genotype_data, graph_type=names(graph_type_mapping), filter_components=FALSE, plot=FALSE) {
    validate_sample_genotype_data(sample_genotype_data)
    
    graph_type <- as.character(graph_type)
    graph_type <- match.arg(graph_type)
    
    if (graph_type == "combined") {
        genotype_graph <- generate_graph(sample_genotype_data, "genotype")
        E(genotype_graph)$genotypes <- TRUE
        label_graph <- generate_graph(sample_genotype_data, "label")
        E(label_graph)$labels <- TRUE 
        graph <- graph.union(genotype_graph, label_graph, byname=TRUE)
        E(graph)[is.na(E(graph)$genotypes)]$genotypes <- FALSE
        E(graph)[is.na(E(graph)$labels)]$labels <- FALSE
        E(graph)$concordant <- E(graph)$genotypes & E(graph)$labels

        if (filter_components) {
            V(graph)$temp_component_id <- clusters(graph)$membership
            filtered_components <- as_data_frame(graph, what="edges") %>% 
                left_join(as_data_frame(graph, what="vertices"), by=c("from"="name")) %>% 
                group_by(temp_component_id) %>% 
                summarize(n_nonconcordant_edges = sum(genotypes) + sum(labels) - 2*sum(concordant)) %>% 
                filter(n_nonconcordant_edges > 0) %>% 
                pull(temp_component_id)
            filtered_vertices <- V(graph)[V(graph)$temp_component_id %in% filtered_components]
            graph <- delete_vertex_attr(graph, "temp_component_id")
            graph <- subgraph(graph, filtered_vertices)
        }
    } else {
        group_col <- graph_type_mapping[[graph_type]]
        edges <- sample_genotype_data %>%
            group_by_at(group_col) %>%
            mutate(
                sample_a = Sample_ID,
                sample_b = list(Sample_ID)
            ) %>%
            ungroup() %>% 
            unnest(sample_b) %>%
            transmute(
                sample1 = pmin(sample_a, sample_b),
                sample2 = pmax(sample_a, sample_b)
            ) %>%
            filter(sample1 != sample2) %>%
            distinct()
        vertices <- sample_genotype_data[, "Sample_ID", drop=FALSE]
        graph <- graph_from_data_frame(edges, vertices=vertices, directed=FALSE)
    }
    
    if (graph_type == "combined") {
        E(graph)$edge_colors <- ifelse(E(graph)$concordant, "green", ifelse(E(graph)$genotypes, "orange", "cornflowerblue"))
    } else if (graph_type == "label") {
        E(graph)$edge_colors <- "cornflowerblue"
    } else {
        E(graph)$edge_colors <- "orange"
    }

    if (plot) {
        plot_graph(graph) 
    }
    return(graph)
}

## TODO: show removals as well
generate_corrections_graph <- function(sample_genotype_data, plot=FALSE) {
    validate_sample_genotype_data(sample_genotype_data, init_sample_label_required=TRUE)
    applied_relabels <- sample_genotype_data[, c("Init_Sample_ID", "Sample_ID")] %>% 
        filter(Sample_ID != Init_Sample_ID & !is.na(Sample_ID))
    graph <- graph_from_data_frame(applied_relabels, directed=TRUE)
    
    if (plot) {
        plot_graph(graph)
    }
    return(graph)
}

## TODO: is there a better R data structure for putative_subjects? In Python I'd use a dict
generate_relabels_graph_from_putative_subjects <- function(sample_genotype_data, putative_subjects) {
    validate_sample_genotype_data(sample_genotype_data)
    validate_putative_subjects(putative_subjects)
    putative_subjects_list <- as.list(setNames(putative_subjects$Subject_ID, putative_subjects$Genotype_Group_ID))
    
    potential_mislabel_univ <- sample_genotype_data %>%
        mutate(
            Putative_Subject_ID = sapply(Genotype_Group_ID, \(x) putative_subjects_list[[x]]),
            Inferred_Correctly_Labeled = Subject_ID == Putative_Subject_ID
        ) %>% 
        filter(!Inferred_Correctly_Labeled) %>% 
        pull(Sample_ID)
    n <- length(potential_mislabel_univ)
    
    relabels_adjacency_mat <- matrix(FALSE, nrow=n, ncol=n)
    rownames(relabels_adjacency_mat) <- colnames(relabels_adjacency_mat) <- potential_mislabel_univ
    for (sample_id in potential_mislabel_univ) {
        genotype_group_id <- sample_genotype_data[sample_genotype_data$Sample_ID == sample_id, ]$Genotype_Group_ID[[1]]
        inferred_subject_id <- ifelse(genotype_group_id %in% names(putative_subjects_list), putative_subjects_list[[genotype_group_id]], NA_character_)
        if (!is.na(inferred_subject_id)) {
            potential_relabels <- sample_genotype_data %>% 
                filter(
                    Sample_ID %in% potential_mislabel_univ,
                    Subject_ID == inferred_subject_id,
                    Genotype_Group_ID != genotype_group_id
                ) %>% 
                pull(Sample_ID)
            relabels_adjacency_mat[sample_id, potential_relabels] <- TRUE
        }
    }
    relabels_graph <- graph_from_adjacency_matrix(relabels_adjacency_mat, mode="directed")
    
    ## Filter out samples that have no edges
    relabels_graph <- subgraph(relabels_graph, V(relabels_graph)[degree(relabels_graph, mode="all") > 0])
    return(relabels_graph)
}

## TODO: drop duplicate cycles
find_directed_cycles <- function(graph, cutoff=1) {
    assert_that(is_directed(graph), 
                msg="Invalid input: param 'graph' must be directed")
    cycles <- list()
    for (vertex in V(graph)) {
        in_neighbors <- names(neighbors(graph, vertex, mode="in"))
        for (in_neighbor in in_neighbors) {
            simple_paths <- all_simple_paths(graph, vertex, in_neighbor, mode="out", cutoff=cutoff)
            cycles <- append(cycles, simple_paths)
        }
    }
    cycles <- lapply(cycles, names)
    return(cycles)
}

relabel_cycles <- function(relabels_graph) {
    all_relabeled_samples <- NULL
    all_cycles <- list()
    cutoff <- 1
    while (cutoff < max(table(clusters(relabels_graph)$membership))) {
        curr_cycles <- find_directed_cycles(relabels_graph, cutoff=cutoff)
        for (curr_cycle in curr_cycles) {
            if (!any(curr_cycle %in% all_relabeled_samples)) {
                all_cycles <- append(all_cycles, list(curr_cycle))
                all_relabeled_samples <- c(all_relabeled_samples, curr_cycle)
                relabels_graph <- delete_vertices(relabels_graph, curr_cycle)
            }
        }
        cutoff <- cutoff + 1
    }
    
    relabels <- data.frame(relabel_from=character(0), relabel_to=character(0))
    for (curr_cycle in all_cycles) {
        n <- length(curr_cycle)
        curr_relabels <- data.frame(
            relabel_from = curr_cycle,
            relabel_to = c(curr_cycle[2:n], curr_cycle[1])
        )
        relabels <- rbind(relabels, curr_relabels)
    }
    return(relabels)
}

relabel_sample_genotype_data <- function(sample_genotype_data, relabels) {
    validate_sample_genotype_data(sample_genotype_data)
    validate_relabels(sample_genotype_data, relabels)
    
    relabeled_sample_genotype_data <- sample_genotype_data %>%  
        left_join(relabels, by = c("Sample_ID"="relabel_from")) %>% 
        mutate(
            Sample_ID = ifelse(!is.na(relabel_to), relabel_to, Sample_ID),
            ## TODO: fix this
            Subject_ID = str_extract(Sample_ID, rex(start, not("_")))
    ) %>% select(-relabel_to)
    combined_graph <- generate_graph(relabeled_sample_genotype_data, graph_type="combined")
    relabeled_sample_genotype_data %<>%
        mutate(
            Component_ID = clusters(combined_graph)$membership[Sample_ID]
        )
    return(relabeled_sample_genotype_data)
}

```

## Heuristics

```{r}

##################################################################
###################         HEURISTICS         ###################
##################################################################

genotype_group_vote <- function(sample_genotype_data) {
    votes <- sample_genotype_data %>% 
        group_by(Subject_ID, Genotype_Group_ID) %>% 
        summarize(n=n(), .groups='drop') %>% 
        pivot_wider(names_from=Subject_ID, values_from=n) %>% 
        mutate_all(~ifelse(is.na(.), 0, .)) %>% 
        column_to_rownames("Genotype_Group_ID") %>% 
        as.matrix()
    return(votes)
}

# 1. For each Genotype_Group_ID, determine the unique majority Subject_ID
# 2. For each Subject_ID, determine unique majority Genotype_Group_ID
# 3. Find the Genotype_Group_ID/Subject_ID pairs where these two mappings intersect
get_majority_majority_pairs <- function(sample_genotype_data) {
    validate_sample_genotype_data(sample_genotype_data)
    votes <- genotype_group_vote(sample_genotype_data)
    votes_by_genotype <- data.frame(
        Genotype_Group_ID = rownames(votes),
        Max_Subject_ID = colnames(votes)[apply(votes, 1, which.max)],
        n = rowSums(votes),
        n_Max_Subject_ID = apply(votes, 1, max)
    ) %>%
        filter(
            n_Max_Subject_ID >= 2,
            n_Max_Subject_ID > n/2
        ) %>% 
        rename(Subject_ID = Max_Subject_ID) %>% 
        select(Genotype_Group_ID, Subject_ID)
    votes_by_subject <- data.frame(
        Subject_ID = colnames(votes),
        Max_Genotype_Group_ID = rownames(votes)[apply(votes, 2, which.max)],
        n = colSums(votes),
        n_Max_Genotype_Group_ID = apply(votes, 2, max)
    ) %>% 
        filter(
            n_Max_Genotype_Group_ID >= 2,
            n_Max_Genotype_Group_ID > n/2
        ) %>% 
        rename(Genotype_Group_ID = Max_Genotype_Group_ID) %>% 
        select(Subject_ID, Genotype_Group_ID)
    putative_subjects <- inner_join(votes_by_subject, votes_by_genotype, by=c("Genotype_Group_ID", "Subject_ID"))
    validate_putative_subjects(putative_subjects)
    return(putative_subjects)
}

```

## Comprehensive search

```{r}

##################################################################
###################    COMPREHENSIVE SEARCH    ###################
##################################################################

compute_min_mislabels <- function(sample_genotype_data) {
    validate_sample_genotype_data(sample_genotype_data)
    min_mislabels <- sample_genotype_data %>% 
        group_by(Genotype_Group_ID) %>% 
        summarize(
            n = n(),
            n_max_count = max(table(Subject_ID)),
            n_min_mislabels = n - n_max_count
        )
    return(sum(min_mislabels$n_min_mislabels))
}

## TODO: have this use the general relabels_graph functions
min_swaps_comprehensive_search <- function(connected_component) {
    validate_sample_genotype_data(connected_component)
    ## What if number of genotype groups doesn't match number of unique subjects?
    ## For now just pass out of it
    if (length(unique(connected_component$Genotype_Group_ID)) != length(unique(connected_component$Subject_ID))) {
        return(data.frame(relabel_from=character(0), relabel_to=character(0)))
    }
    
    perm_genotypes <- t(simplify2array(permn(unique(connected_component$Subject_ID))))
    colnames(perm_genotypes) <- sort(unique(connected_component$Genotype_Group_ID))
    ## Cheating by only including cases where the count in genotype group aligns with the count in Subject_ID
    genotype_counts <- connected_component %>% 
        count(Genotype_Group_ID) %>% 
        column_to_rownames(var = "Genotype_Group_ID")
    genotype_counts <- genotype_counts[colnames(perm_genotypes), ]
    subject_counts <- connected_component %>% 
        count(Subject_ID) %>% 
        column_to_rownames(var = "Subject_ID")
    count_concordance <- sapply(1:nrow(perm_genotypes), \(x) all(subject_counts[perm_genotypes[x, ], ] == genotype_counts))
    perm_genotypes <- perm_genotypes[count_concordance, , drop=FALSE]
    if (nrow(perm_genotypes) == 0) {
        return(data.frame(relabel_from=character(0), relabel_to=character(0)))
    }
    
    ## For each Genotype_Group_ID/Subject_ID permutation, determine the implied Sample_ID/Subject_ID permutation
    perm_samples <- matrix(nrow=nrow(perm_genotypes), ncol=nrow(connected_component), dimnames=list(NULL, rownames(connected_component)))
    for (i in 1:nrow(perm_samples)) {
        perm_samples[i, ] <- perm_genotypes[i, ][connected_component$Genotype_Group_ID]
    }
    
    ## For each Sample_ID/Subject_ID permutation, determine number of implied mislabels
    curr_subjects <- t(replicate(n=nrow(perm_samples), connected_component$Subject_ID))
    colnames(curr_subjects) <- colnames(perm_samples)
    n_min_mislabels <- compute_min_mislabels(connected_component)
    perm_genotypes <- as.data.frame(perm_genotypes) %>% 
        mutate(
            n_min_mislabels = n_min_mislabels,
            n_implied_mislabels = rowSums(perm_samples != curr_subjects)
        ) %>% 
        arrange(n_implied_mislabels)
    
    ## For now, just take top row
    ## TODO: if there is a tie, return some indication...maybe a list of everything part of the tie
    connected_component %<>%
        mutate(
            Assumed_Subject_ID = sapply(Genotype_Group_ID, \(x) perm_genotypes[1, x]),
            Assumed_Mislabeled = Subject_ID != Assumed_Subject_ID
        )
    assumed_mislabels <- connected_component[connected_component$Assumed_Mislabeled, "Sample_ID"]
    relabels_adj_matrix <- matrix(FALSE, nrow=length(assumed_mislabels), length(assumed_mislabels),
                                  dimnames=list(assumed_mislabels, assumed_mislabels))
    for (sample_id in assumed_mislabels) {
        assumed_subject_id <- connected_component[connected_component["Sample_ID"] == sample_id, ]$Assumed_Subject_ID[[1]]
        possible_relabels <- connected_component %>% 
            filter(
                Sample_ID %in% assumed_mislabels,
                Subject_ID == assumed_subject_id
            ) %>% 
            pull(Sample_ID)
        relabels_adj_matrix[sample_id, possible_relabels] = TRUE
    }
    relabels_graph <- graph_from_adjacency_matrix(relabels_adj_matrix, mode="directed")
    
    all_relabeled_samples <- NULL
    all_cycles <- list()
    cutoff <- 1
    while (vcount(relabels_graph) > 0) {
        curr_cycles <- find_directed_cycles(relabels_graph, cutoff=cutoff)
        for (curr_cycle in curr_cycles) {
            if (!any(curr_cycle %in% all_relabeled_samples)) {
                all_cycles <- append(all_cycles, list(curr_cycle))
                all_relabeled_samples <- c(all_relabeled_samples, curr_cycle)
                relabels_graph <- delete_vertices(relabels_graph, curr_cycle)
            }
        }
        cutoff <- cutoff + 1
    }
    
    relabels <- data.frame(relabel_from=character(0), relabel_to=character(0))
    for (curr_cycle in all_cycles) {
        n <- length(curr_cycle)
        curr_relabels <- data.frame(
            relabel_from = curr_cycle,
            relabel_to = c(curr_cycle[2:n], curr_cycle[1])
        )
        relabels <- rbind(relabels, curr_relabels)
    }
    
    return(relabels)
}

```

## Local search

```{r}

##################################################################
###################        LOCAL SEARCH        ###################
##################################################################

objective_genotype_entropy = function(sample_genotype_data) {
    sample_genotype_data %>% 
        group_by(Genotype_Group_ID) %>%
        summarize(genotype_entropy = n()*entropy(table(Subject_ID)))  %>%
        select(genotype_entropy) %>%
        sum()
}

objective_hamming_distance <- function(sample_genotype_data) {
    labels_graph <- generate_graph(sample_genotype_data, "label")
    genotype_graph <- generate_graph(sample_genotype_data, "genotype")
    int_graph <- graph.intersection(labels_graph, genotype_graph)
    return(ecount(labels_graph) + ecount(genotype_graph) - 2*ecount(int_graph))
}

## If filter_concordant_vertices is true, filter out any vertices that have green edges 
## This should speed up the search, but misses cases where 2 samples from the same genotype
## are mislabeled into the same incorrect genotype
local_search_correct <- function(sample_genotype_data, objective, n_iter=1, filter_concordant_vertices=TRUE) {
    search_objectives <- list(
        genotype_entropy = objective_genotype_entropy,
        hamming_distance = objective_hamming_distance
    )
    objective_options <- names(search_objectives)
    objective <- as.character(objective)
    objective <- match.arg(objective, names(search_objectives))
    if (objective %in% objective_options) {
        objective_function <- search_objectives[[objective]]
    } else {
        stop(glue("Invalid: unrecognized value for 'objective': {objective}"))
    }

    ## For any objective, the only improving swaps involve 2 samples connected
    ## to a common sample but not each other. One has a genotype edge and one a label edge
    find_neighbors <- function(combined_graph) {
        v_filtered <- V(combined_graph)
        if (filter_concordant_vertices) {
            v_filtered <- NULL
            for (v in V(combined_graph)) {
                v_neighbors <- neighbors(combined_graph, v)
                concordant_edge_count <- sum(E(combined_graph)[v %--% v_neighbors]$concordant)
                if (concordant_edge_count == 0) {
                    v_filtered <- c(v_filtered, v)
                }
            }
        }
        graph_distances <- distances(combined_graph, v=v_filtered, to=v_filtered)
        dist_equals_2 <- graph_distances == 2
        row_indices <- row(dist_equals_2)[dist_equals_2]
        col_indices <- col(dist_equals_2)[dist_equals_2]
        unique_pairs <- data.frame(
            Row = rownames(graph_distances)[row_indices],
            Col = colnames(graph_distances)[col_indices]) %>%
            transmute(
                Sample_A = pmin(Row, Col),
                Sample_B = pmax(Row, Col)
            ) %>% unique()
        return(unique_pairs)
    }
    
    calc_swapped_objective <- function(swap_from, swap_to) {
        swap_relabels <- data.frame(relabel_from=c(swap_from, swap_to), relabel_to=c(swap_to, swap_from))
        swapped_sample_genotype_data <- relabel_sample_genotype_data(sample_genotype_data, swap_relabels) 
        return(objective_function(swapped_sample_genotype_data))
    }

    for (curr_iter in 1:n_iter) {
        combined_graph <- generate_graph(sample_genotype_data, "combined")
        neighbors <- find_neighbors(combined_graph) %>% 
            left_join(sample_genotype_data[, c("Sample_ID", "Component_ID")], by=c("Sample_A"="Sample_ID"))
        if (nrow(neighbors) == 0) { break }
        neighbor_objectives <- neighbors %>% 
            mutate(
                base = objective_function(sample_genotype_data),
                objective = mapply(calc_swapped_objective, swap_from=Sample_A, swap_to=Sample_B),
                delta = objective - base
            )
        relabels <- neighbor_objectives %>%
            group_by(Component_ID) %>% 
            filter((delta < 0) & (delta == min(delta)))
        if (nrow(relabels) == 0) { break }
        relabels <- relabels %>%
            sample_n(1) %>%
            ungroup(Component_ID) %>% 
            transmute(
                relabel_from=Sample_A,
                relabel_to=Sample_B
            )
        relabels <- rbind(relabels, data.frame(relabel_from=relabels$relabel_to, relabel_to=relabels$relabel_from))
        sample_genotype_data <- relabel_sample_genotype_data(sample_genotype_data, relabels)
    }
    return(sample_genotype_data)
}

```

## Define correction algoritms

```{r}

correct_majority_cycles <- function(sample_genotype_data) {
    putative_subjects <- get_majority_majority_pairs(sample_genotype_data)
    relabels_graph <- generate_relabels_graph_from_putative_subjects(sample_genotype_data, putative_subjects)
    majority_cycle_relabels <- relabel_cycles(relabels_graph)
    validate_relabels(sample_genotype_data, majority_cycle_relabels)
    sample_genotype_data <- relabel_sample_genotype_data(sample_genotype_data, majority_cycle_relabels)
    return(sample_genotype_data)
}

correct_comprehensive_search <- function(sample_genotype_data, ...) {
    combined_graph <- generate_graph(sample_genotype_data, graph_type="combined")
    sample_genotype_data %<>% 
        mutate(
            Temp_Component_ID = str_c("Temp_Component_", clusters(combined_graph)$membership)
        )
    temp_component_ids <- unique(sample_genotype_data$Temp_Component_ID)
    relabels <- data.frame(relabel_from=character(0), relabel_to=character(0))
    for (temp_component_id in temp_component_ids) {
        connected_component <- sample_genotype_data %>% filter(Temp_Component_ID == temp_component_id)
        ## The connected component is fully resolved if there's exactly one Subject_ID and one Genotype_Group_ID
        if (length(unique(connected_component$Subject_ID)) == 1 & length(unique(connected_component$Genotype_Group_ID)) == 1) {
            next
        }
        if (length(unique(connected_component$Subject_ID)) <= max_subjects) {
            curr_relabels <- min_swaps_comprehensive_search(connected_component, ...)
            relabels <- rbind(relabels, curr_relabels)
        }
    }
    sample_genotype_data %<>% select(-Temp_Component_ID)
    sample_genotype_data <- relabel_sample_genotype_data(sample_genotype_data, relabels)
    return(sample_genotype_data)
}

correct_local_search_entropy <- function(sample_genotype_data, ...) {
    return(local_search_correct(sample_genotype_data, "genotype_entropy", ...))
}

correct_ensemble <- function()

```

## Output correction results

```{r}



```

# Define simulation  mislabel handlers

```{r}

##################################################################
#################    DEFINE MISLABEL HANDLERS    #################
##################################################################

handle_mislabels_ignore <- identity

handle_mislabels_remove_oracle <- function(elist) {
    return(elist[, !elist$targets$Mislabeled])
}

## This should just recover the original elist with no mislabeling
handle_mislabels_correct_oracle <- function(elist) {
    return(reorder_elist_samples(elist, elist$targets$Sample_ID))
}

## Remove all samples where the labeled Subject_ID doesn't match the majority 
## Subject_ID in its genotype groupset
handle_mislabels_remove_majority <- function(elist) {
    votes <- genotype_group_vote(elist)
    votes_by_genotype <- data.frame(
        Genotype_Group_ID = rownames(votes),
        Max_Subject_ID = colnames(votes)[apply(votes, 1, which.max)],
        n = rowSums(votes),
        n_Max_Subject_ID = apply(votes, 1, max)
    ) %>%
        filter(
            n_Max_Subject_ID > n/2
        )
    remove_samples <- elist$targets %>% 
        left_join(votes_by_genotype[, c("Genotype_Group_ID", "Max_Subject_ID")], by="Genotype_Group_ID") %>% 
        mutate(
            Inferred_Mislabeled = is.na(Max_Subject_ID) | Subject_ID != Max_Subject_ID
        ) %>% 
        filter(Inferred_Mislabeled) %>% 
        pull(Sample_ID)
    elist <- elist[, !(elist$targets$Sample_ID %in% remove_samples)]
    return(elist)
}

handle_mislabels_correct_majority_cycles <- function(elist) {
    relabels_graph <- get_majority_majority_relabels_graph(elist)
    all_relabeled_samples <- NULL
    all_cycles <- list()
    cutoff <- 1
    while (cutoff < max(table(clusters(relabels_graph)$membership))) {
        curr_cycles <- find_directed_cycles(relabels_graph, cutoff=cutoff)
        for (curr_cycle in curr_cycles) {
            if (!any(curr_cycle %in% all_relabeled_samples)) {
                all_cycles <- append(all_cycles, list(curr_cycle))
                all_relabeled_samples <- c(all_relabeled_samples, curr_cycle)
                relabels_graph <- delete_vertices(relabels_graph, curr_cycle)
            }
        }
        cutoff <- cutoff + 1
    }
    
    relabels <- data.frame(relabel_from=character(0), relabel_to=character(0))
    for (curr_cycle in all_cycles) {
        n <- length(curr_cycle)
        curr_relabels <- data.frame(
            relabel_from = curr_cycle,
            relabel_to = c(curr_cycle[2:n], curr_cycle[1])
        )
        relabels <- rbind(relabels, curr_relabels)
    }
    elist <- relabel_elist_samples(elist, relabels)
    return(elist)
}

handle_mislabels_correct_majority_swaps <- function(elist) {
    relabels_graph <- get_majority_majority_relabels_graph(elist)
    unambiguous_vertices <- names(V(relabels_graph)[degree(relabels_graph, mode="out") == 1])
    unambiguous_neighbors <- NULL
    for (vertex in unambiguous_vertices) {
        unambiguous_neighbors <- c(unambiguous_neighbors, names(neighbors(relabels_graph, vertex, "out")))
    }
    unambiguous_neighbors <- setdiff(unambiguous_neighbors, unambiguous_vertices)
    unambiguous_relabels_graph <- subgraph(relabels_graph, union(unambiguous_vertices, unambiguous_neighbors))
    # Delete outgoing edges from the neighbors
    for (vertex in unambiguous_neighbors) {
        out_edges <- E(unambiguous_relabels_graph)[.from(vertex)]  # Get outgoing edges from the vertex
        unambiguous_relabels_graph <- delete_edges(unambiguous_relabels_graph, out_edges)       # Delete the outgoing edges
    }
    
    ## Force cycle closures
    relabels_graph <- unambiguous_relabels_graph
    V(unambiguous_relabels_graph)$cycle_id <- clusters(unambiguous_relabels_graph)$membership
    V(unambiguous_relabels_graph)$n_out <- degree(unambiguous_relabels_graph, mode="out")
    V(unambiguous_relabels_graph)$n_in <- degree(unambiguous_relabels_graph, mode="in")
    ## For every cycle, there should be exactly one vertex with no in edges and on vertex with no out edges
    for (curr_cycle_id in unique(V(unambiguous_relabels_graph)$cycle_id)) {
        start_vertex <- V(unambiguous_relabels_graph)[V(unambiguous_relabels_graph)$cycle_id == curr_cycle_id &
                                                      V(unambiguous_relabels_graph)$n_in == 0]
        end_vertex <- V(unambiguous_relabels_graph)[V(unambiguous_relabels_graph)$cycle_id == curr_cycle_id &
                                                      V(unambiguous_relabels_graph)$n_out == 0]
        assert_that(
            length(start_vertex) == 1,
            length(end_vertex) == 1,
            msg = "Something wrong in linear swaps"
        )
        relabels_graph %<>% add_edges(c(end_vertex[[1]]$name, start_vertex[[1]]$name))
    }
    
    relabels <- as.data.frame(get.edgelist(relabels_graph))
    colnames(relabels) <- c("relabel_from", "relabel_to")
    elist <- relabel_elist_samples(elist, relabels)
    return(elist)
}

# Comprehensive search
# For each connected component that's small enough
# 1. Find the subject_id permutation that minimizes number of mislabels (or is within some threshold)
# 2. Generate relabels graph
# 3. Greedily correct by resolving smallest cycles first
handle_mislabels_comprehensive_search <- function(elist, max_subjects=9) {
    combined_graph <- generate_graph(elist, "combined")
    connected_components <- elist$targets[, c("Sample_ID", "Subject_ID", "Genotype_Group_ID")] %>% 
        mutate(
            Component_ID = str_c("Component_", clusters(combined_graph)$membership)
        )
    component_ids <- unique(connected_components$Component_ID)
    relabels <- data.frame(relabel_from=character(0), relabel_to=character(0))
    for (component_id in component_ids) {
        connected_component <- connected_components %>% filter(Component_ID == component_id)
        ## The connected component is fully resolved if there's only one Subject_ID and one Genotype_Group_ID
        if (length(unique(connected_component$Subject_ID)) == 1 & length(unique(connected_component$Genotype_Group_ID)) == 1) {
            next
        }
        if (length(unique(connected_component$Subject_ID)) <= max_subjects) {
            curr_relabels <- min_swaps_comprehensive_search(connected_component)
            relabels <- rbind(relabels, curr_relabels)
        }
    }
    elist <- relabel_elist_samples(elist, relabels)
    return(elist)
}

handle_mislabels_correct_local_search_entropy <- function(elist, n_iter=5) {
    return(local_search_correct(elist, objective="genotype_entropy", n_iter=n_iter))
}

handle_mislabels_correct_main_with_remove_majority <- function(elist, n_iter=3, max_subjects=9, n_set=10) {
    curr_set <- 0
    while (curr_set < n_set) {
        elist <- handle_mislabels_comprehensive_search(elist, max_subjects=max_subjects)
        elist <- handle_mislabels_correct_majority_cycles(elist)
        elist <- handle_mislabels_comprehensive_search(elist, max_subjects=max_subjects)
        elist <- handle_mislabels_correct_majority_swaps(elist)
        elist <- handle_mislabels_comprehensive_search(elist, max_subjects=max_subjects)
        if (calc_label_genotype_hamming_distance(elist) == 0) break
        elist <- handle_mislabels_correct_local_search_entropy(elist, n_iter=1)
        curr_set <- curr_set + 1
    }
    elist <- handle_mislabels_remove_majority(elist)
    return(elist)
}

mislabel_handlers <- list(
    ignore = handle_mislabels_ignore,
    remove_oracle = handle_mislabels_remove_oracle,
    correct_oracle = handle_mislabels_correct_oracle,
    correct_main_with_remove_majority = handle_mislabels_correct_main_with_remove_majority
)
handle_mislabels_options <- names(mislabel_handlers)

```

## Wrappers for simulation

```{r}

handle_mislabels_ignore <- identity

handle_mislabels_remove_oracle <- function(elist) {
    return(elist[, !elist$targets$Mislabeled])
}

## This should just recover the original elist with no mislabeling
handle_mislabels_correct_oracle <- function(elist) {
    return(reorder_elist_samples(elist, elist$targets$Sample_ID))
}

```

# Define simulaton swap handlers

```{r}

genswaps_random = function(elist, n_mislabels) {
    correct_ctrl_samples <- elist$targets %>% filter(Status == "Control" & !Mislabeled) %>% pull(Sample_ID)
    correct_case_samples <- elist$targets %>% filter(Status == "Case" & !Mislabeled) %>% pull(Sample_ID)
    n_swaps <- floor(n_mislabels / 2)
    swaps <- cbind(
        sample(correct_ctrl_samples, n_swaps),
        sample(correct_case_samples, n_swaps)
    )
    return(swap_elist_samples(elist, swaps))
}

genswaps_random_with_replacement = function(elist, n_mislabels) {
    n_correct_labels <- nrow(elist$targets %>% filter(!Mislabeled))
    assert_that(n_mislabels <= n_correct_labels, 
                msg = glue("Can't generate {n_mislabels} new mislabels when there are only {n_correct_samples} correctly labeled samples"))
    n_curr_mislabels <- nrow(elist$targets %>% filter(Mislabeled))
    n_goal_mislabels <- n_curr_mislabels + n_mislabels
    n_rounds <- 0
    while (n_curr_mislabels < n_goal_mislabels) {
        n_new_mislabels <- n_goal_mislabels - n_curr_mislabels
        mislabeled_samples <- elist$targets %>% filter(Mislabeled) %>% pull(Sample_ID)
        correct_samples <- elist$targets %>% filter(!Mislabeled) %>% pull(Sample_ID)
        all_samples <- c(mislabeled_samples, correct_samples)
        if (n_new_mislabels == 1) {
            swaps <- cbind(
                sample(mislabeled_samples, 1),
                sample(correct_samples, 1)
            )
        } else if (n_new_mislabels == 2) {
            swaps <- matrix(sample(correct_samples, 2), ncol = 2)
        } else if (n_rounds > 5) {
            swaps <- cbind(
                sample(mislabeled_samples, n_new_mislabels),
                sample(correct_samples, n_new_mislabels)
            )
        } else {
            n_swaps <- floor(n_new_mislabels / 2)
            swaps <- matrix(sample(all_samples, 2 * n_swaps, replace = TRUE), ncol = 2)
        }
        elist <- swap_elist_samples(elist, swaps)
        n_rounds <- n_rounds + 1
        n_curr_mislabels <- nrow(elist$targets %>% filter(Mislabeled))
    }
    return(elist)
}

genswaps_systematic = function(elist, n_mislabels) {
    correct_samples <- elist$targets %>% filter(!Mislabeled) %>% pull(Sample_ID)
    n_swaps <- floor(n_mislabels / 2)
    swaps <- cbind(
        swaps <- matrix(sample(correct_samples, n_swaps * 2), ncol = 2)
    )
    return(swap_elist_samples(elist, swaps))
}

swap_handlers <- list(
    random = genswaps_random,
    random_with_replacement = genswaps_random_with_replacement,
    systematic = genswaps_systematic
)
handle_swaps_options <- names(swap_handlers)

```

# Define simulation code

```{r}

## Example values for testing
local({
    n_subjects_per_group = 30
    n_samples_per_group = 150
    n_features = 2
    n_mislabels = 100
    n_sv = 2
    fraction_de_case = 0.5
    case_sd = 0.1
    subject_sd = 0.1
    sv_sd = 0.1
    resid_sd = 0.1
    sex_sd = 0.1
    age_sd = 0.1
    swap_model = "random_with_replacement"
    seed = 1986
})

sim_mislabeled_data <- function (
    n_subjects_per_group,
    n_samples_per_group,
    n_features,
    n_mislabels,
    n_sv,
    fraction_de_case,
    case_sd,
    sv_sd,
    subject_sd,
    resid_sd,
    sex_sd = 0,
    age_sd = 0,
    swap_model = handle_swaps_options,
    seed
) {
    if (!missing(seed)) {
        sim_params <- mget(c(
            "n_subjects_per_group",
            "n_samples_per_group",
            "n_features",
            "n_mislabels",
            "n_sv",
            "fraction_de_case",
            "case_sd",
            "subject_sd",
            "sv_sd",
            "resid_sd",
            "sex_sd",
            "age_sd",
            "swap_model"
        ))
        res <- with_seed(seed, do.call(sim_mislabeled_data, sim_params))
        res$params$seed <- seed
        return(res)
    }
    
    n_samples <- 2 * n_samples_per_group
    
    swap_handlers <- list(
        random = genswaps_random,
        random_with_replacement = genswaps_random_with_replacement,
        systematic = genswaps_systematic
    )
    swap_model <- as.character(swap_model)
    swap_model <- match.arg(swap_model)
    if (swap_model %in% c("random", "systematic") & n_mislabels %% 2 == 1) {
        warning(glue("For random and systematic modes, n_mislabels must be even. Setting n_mislabels to be {2 * floor(n_mislabels / 2)}"))
        n_mislabels <- 2 * floor(n_mislabels / 2)
    }
    handle_swaps_function <- swap_handlers[[swap_model]]
    
    assert_that(
        n_subjects_per_group > 1,
        n_samples_per_group >= n_subjects_per_group,
        n_features > 0,
        n_mislabels >= 0 & n_mislabels != 1,
        n_mislabels <= n_samples,
        n_sv >= 0,
        fraction_de_case >= 0,
        fraction_de_case <= 1,
        case_sd >= 0,
        subject_sd >= 0,
        sv_sd >= 0,
        resid_sd >= 0,
        sex_sd >= 0,
        age_sd >= 0,
        swap_model %in% handle_swaps_options
    )
    if (n_sv < 1 && sv_sd > 0) {
        warning("Setting SV signal to zero since there are not SVs")
        n_sv <- 1
        sv_sd <- 0
    }
    
    ## Generate the subjects
    ctrl_subjects <- generate_ids("Ctrl", n_subjects_per_group)
    case_subjects <- generate_ids("Case", n_subjects_per_group)
    subject_meta_table <- tibble(
        Subject_ID = c(ctrl_subjects, case_subjects),
        Status = c(rep_along(ctrl_subjects, "Control"), rep_along(case_subjects, "Case")) %>%
            factor(levels = c("Control", "Case"))
    ) %>% 
        mutate(
            Sex = sample(c("Male", "Female"), size=n(), replace=TRUE),
            Age = rbinom(n=n(), size=60, prob=0.2) + 20,
            n_samples = 1
        )
    ## Determine number of samples per subject
    addl_samples <- c(
        table(sample(ctrl_subjects, n_samples_per_group - n_subjects_per_group, replace = TRUE)),
        table(sample(case_subjects, n_samples_per_group - n_subjects_per_group, replace = TRUE))) %>% 
        as.data.frame() %>% 
        rename(c("addl_samples" = "."))
    addl_samples$Subject_ID <- rownames(addl_samples)
    subject_meta_table %<>%
        left_join(addl_samples, by="Subject_ID") %>% 
        replace_na(list(addl_samples=0)) %>% 
        mutate(
            n_samples = n_samples + addl_samples
        ) %>% select(-addl_samples)

    ## Generate the samples
    num_digits <- digits(max(subject_meta_table$n_samples))
    sample_meta_table <- tibble(
        Subject_ID = rep.int(subject_meta_table$Subject_ID, times=subject_meta_table$n_samples)
    ) %>% 
        group_by( Subject_ID ) %>% 
        mutate(
            Sample_ID = generate_ids(str_c(Subject_ID, "_Sample"), n(), num_digits=num_digits)
        ) %>% 
        ungroup() %>% 
        left_join(
            subject_meta_table, by="Subject_ID"
        ) %>% 
        mutate(
            E_Sample_ID = Sample_ID,
            E_Subject_ID = Subject_ID,
            Genotype_Group_ID = str_c("Genotype_Group", as.character(as.numeric(factor(E_Subject_ID)))),
            Mislabeled = FALSE,
            Mislabeled_Subject = FALSE
        ) %>% 
        select(-n_samples) %>% 
        relocate(Sample_ID)
    
    assert_that(length(unique(sample_meta_table$Sex)) > 1, msg = "Only one sex simulated")
    
    sv_names <- generate_ids("SV", n_sv)
    for (svi in sv_names) {
        sample_meta_table[[svi]] <- rnorm(nrow(sample_meta_table))
    }
    
    n_de_features <- round(n_features * fraction_de_case)
    if (n_de_features == 0 && fraction_de_case != 0) {
        warning("fraction_de_case is too small, no features are DE")
    }
    
    ## Generate the features
    feature_meta_table <- tibble(
        Feature_Number = seq_len(n_features),
        DE = Feature_Number <= n_de_features,
        Feature_ID = generate_ids("Feature", n_features) %>%
            str_c(if_else(DE, "_DE", ""))
    ) %>%
        select(Feature_ID, Feature_Number, DE, everything())
    
    ## Generate the coefs
    design_case <- model.matrix(~1 + Status, sample_meta_table)[, 2, drop = FALSE] %>%
        ## Convert to sum-to-zero
        subtract(mean(unique(.)))
    design_sex <- model.matrix(~1 + Sex, sample_meta_table)[, 2, drop = FALSE] %>%
        subtract(mean(unique(.)))
    design_age <- as.matrix(sample_meta_table["Age"]) %>%
        ## Make sure that age design has same scale as other SVs (mean=0, sd=1)
        scale()
    design_subject <- model.matrix(~0 + Subject_ID, sample_meta_table)
    design_sv <- as.matrix(sample_meta_table[sv_names])
    ## Use abs so that all true logFC are positive
    eta_case <- design_case %*% matrix(ncol = n_features, nrow = ncol(design_case), abs(rnorm(n_features * ncol(design_case)))) %>%
        ## Set all eta to 0 for non-DE genes
        scale(center = FALSE, scale = if_else(feature_meta_table$DE, 1, Inf))
    eta_sex <- design_sex %*% matrix(ncol = n_features, nrow = ncol(design_sex), rnorm(n_features * ncol(design_sex)))
    eta_age <- design_age %*% matrix(ncol = n_features, nrow = ncol(design_age), rnorm(n_features * ncol(design_age)))
    eta_subject <- design_subject %*% matrix(ncol = n_features, nrow = ncol(design_subject), rnorm(n_features * ncol(design_subject)))
    eta_sv <- design_sv %*% matrix(ncol = n_features, nrow = ncol(design_sv), rnorm(n_features * ncol(design_sv)))
    eta_resid <- matrix(ncol = n_features, nrow = nrow(sample_meta_table), rnorm(n_features * nrow(sample_meta_table)))
    
    ## Put all the expression effects together
    expr_mat <- t(
        eta_case * case_sd +
            eta_sex * sex_sd + 
            eta_age * age_sd +
            eta_subject * subject_sd + 
            eta_sv * sv_sd +
            eta_resid * resid_sd
    ) %>%
        set_colnames(sample_meta_table$Sample_ID) %>%
        set_rownames(feature_meta_table$Feature_ID)
    attr(expr_mat, "scaled:scale") <- NULL
    
    ## Build the EList
    elist <- new("EList", list(
        E = expr_mat,
        genes = as.data.frame(feature_meta_table),
        targets = as.data.frame(sample_meta_table),
        other = list(
            eta_sv = t(eta_sv),
            eta_case = t(eta_case),
            eta_sex = t(eta_sex),
            eta_age = t(eta_age),
            eta_resid = t(eta_resid)
        ),
        params = mget(c(
            "n_subjects_per_group",
            "n_samples_per_group",
            "n_features",
            "n_mislabels",
            "n_sv",
            "fraction_de_case",
            "case_sd",
            "subject_sd",
            "sv_sd",
            "resid_sd",
            "sex_sd",
            "age_sd",
            "swap_model"
        )),
        ## Store true expressions for reference when relabeling samples
        origs = list(
            E_true = expr_mat
        )
    ))
    
    ## Discard unused eta matrices
    if (case_sd == 0 || n_de_features == 0) {
        elist$other$eta_case <- NULL
    }
    sd_eta_pairs = list(c("sex_sd", "eta_sex"),
                        c("age_sd", "eta_age"),
                        c("sv_sd", "eta_sv"),
                        c("resid_sd", "eta_resid"))
    for (pair in sd_eta_pairs) {
        var_sd <- pair[[1]]
        eta_var <- pair[[2]]
        if (var_sd == 0) {
            elist$other[[eta_var]] <- NULL
        }
    }
  
    ## Apply dimnames to all relevant sub-elements in the EList
    dimnames(elist) <- dimnames(elist)
    
    ## Create mislabeled samples
    tsmsg(glue("Swapping samples with method: {swap_model}"))
    elist <- handle_swaps_function(elist, n_mislabels)

    ## Store original targets so we can access initial Sample_ID/E_Data 
    ## pairs to assess the results of the label correction algorithm
    elist$origs$targets_orig <- elist$targets

    return(elist)
}

## Function to generate simulated data, run the real time learner,
## and save the resulting model
run_sim <- function(..., handle_mislabels = handle_mislabels_options, save_eta_matrices = FALSE, correction_timeout = 15) {
    if (is.function(handle_mislabels)) {
        handle_mislabels_function <- handle_mislabels
        handle_mislabels <- "[custom handler function]"
    } else {
        handle_mislabels <- as.character(handle_mislabels)
        handle_mislabels <- match.arg(handle_mislabels)
        if (!(handle_mislabels %in% handle_mislabels_options)) {
            stop(glue("Unrecognized value for handle_mislabels: {handle_mislabels}"))
        }
        mislabel_handlers <- list(
            ignore = handle_mislabels_ignore,
            remove_oracle = handle_mislabels_remove_oracle,
            correct_oracle = handle_mislabels_correct_oracle,
            correct_majority_cycles = handle_mislabels_correct_majority_cycles,
            correct_majority_swaps = handle_mislabels_correct_majority_swaps,
            remove_majority = handle_mislabels_remove_majority,
            correct_comprehensive_search = handle_mislabels_comprehensive_search,
            correct_local_search_entropy = handle_mislabels_correct_local_search_entropy,
            correct_majority_cycles_with_remove_majority = handle_mislabels_correct_majority_cycles_with_remove_majority,
            correct_majority_cycles_swaps_with_remove_majority = handle_mislabels_correct_majority_cycles_swaps_with_remove_majority,
            correct_majority_cycles_swaps_entropy_with_remove_majority = handle_mislabels_correct_majority_cycles_swaps_entropy_with_remove_majority,
            correct_majority_swaps_comprehensive_with_remove_majority = handle_mislabels_correct_majority_swaps_comprehensive_with_remove_majority,
            correct_entropy_comprehensive_with_remove_majority = handle_mislabels_correct_entropy_comprehensive_with_remove_majority
        )
        handle_mislabels_function <- mislabel_handlers[[handle_mislabels]]
        assert_that(is.function(handle_mislabels_function))
    }

    tsmsg("Simulating dataset")
    ## We simulate 2x as many subjects so we can use the 2nd half
    ## for validation of real time prediction learned from the
    ## entire first half.
    elist <- sim_mislabeled_data(...)
    
    ## The eta matrices take up a lot of space
    if (!save_eta_matrices) {
        tsmsg("Clearing eta matrices")
        elist$other <- NULL
    }
    
    tsmsg("Handling mislabels with action: ", handle_mislabels)
    ## TODO
    R.utils::withTimeout({corrected_elist <- handle_mislabels_function(elist)}, timeout=correction_timeout)
    if (is.null(corrected_elist)) {
        stop(glue("mislabel_handler {handle_mislabels} timed out: {correction_timeout}"))
    } 
    elist <- corrected_elist
    
    tt <- elist$genes %>% 
        as_tibble %>% 
        mutate(logFC = NA_real_, AveExpr = NA_real_, t = NA_real_, P.Value = NA_real_, adj.P.Val = NA_real_)
    
    label_outcomes <- elist$origs$targets_orig %>%
        select(Sample_ID, E_Sample_ID, Mislabeled) %>% 
        ## Need to specify dplyr rename or for some reason it fails in future_Map
        dplyr::rename(
            E_Sample_ID_orig = E_Sample_ID,
            Mislabeled_orig = Mislabeled
        ) %>% 
        left_join(
            elist$targets[, c("Sample_ID", "E_Sample_ID", "Mislabeled")],
            by = "Sample_ID"
        ) %>% dplyr::rename(
            E_Sample_ID_final = E_Sample_ID,
            Mislabeled_final = Mislabeled
        ) %>%
        mutate(
            Outcome = case_when(
                is.na(E_Sample_ID_final) ~ "removed",
                E_Sample_ID_final == E_Sample_ID_orig ~ "ignored",
                !Mislabeled_final ~ "correctly_relabeled",
                Mislabeled_final ~ "incorrectly_relabeled",
                .default = NA
            )
        ) %>% select( Sample_ID, Mislabeled_orig, Outcome )
    
    unique_var_values <- lapply(elist$targets[, c("Status", "Sex", "Age")],
        function(var) {
            return(length(unique(var)))
        })
    if (ncol(elist) == 0 | any(unique_var_values < 2)) {
        ## If all samples are removed or if any variable has fewer than 2 unique values
        ## return a result table with all NA stats
        return(list(tt = as_tibble(tt), label_outcomes = label_outcomes))
    }
    
    tsmsg("Running limma")
    ## We model the surrogate variables because even swaps within
    ## groups will compromise the modeling of SVs, which should
    ## reduce the performance of the model.
    sv_names <- str_subset(colnames(elist$targets), "^SV[0-9]+")
    design_formula <- as.formula(str_c(c("~1", "Status", "Sex", "Age", sv_names), collapse = "+"))
    design <- model.matrix(design_formula, elist$targets)
    
    if (!design_is_identifiable(design)) {
        ## If the design is not identifiable due to nesting
        ## return a result table with all NA stats
        return(list(tt = as_tibble(tt), label_outcomes = label_outcomes))
    }
    
    # If each subject has only one sample, then Subject_ID effect
    # is subsumed by sample residual, and we can fit a fixed effects model
    # Otherwise if there are subjects with multiple samples, the Subject_ID
    # is nested in Status, and we need to fit a mixed model
    if (anyDuplicated(elist$targets$Subject_ID) == 0) {
        fit <- eBayes(lmFit(elist, design), trend = FALSE, robust = FALSE)
    } else {
        # Commenting this out for now since it takes a long time and slows debugging
        # dupcor <- duplicateCorrelation(elist, design, block = elist$targets$Subject_ID)
        # Placeholder correlation
        dupcor <- list(consensus=0.1)
        fit <- eBayes(lmFit(elist, design, block = elist$targets$Subject_ID, correlation=dupcor$consensus), trend = FALSE, robust = FALSE)
    }
    tt <- topTable(fit, number = Inf, coef = "StatusCase")
    
    tsmsg("Collecting results")
    
    return(list(tt = as_tibble(tt), label_outcomes = label_outcomes))
}

```

# Set up simulation grid

```{r}
## TODO: nonlinear time effect - time splines
grid_list <- list(
    tibble(handle_mislabels = handle_mislabels_options),
    tibble(n_mislabels = seq(from = 0, to = 150, by = 10)),
    tibble(swap_model = handle_swaps_options),
    ## Not varying any of these
    tibble(
        n_subjects_per_group = 50,
        n_samples_per_group = 150,
        n_features = 10,
        n_sv = 5,
        fraction_de_case = 0.5,
        case_sd = 0.1,
        subject_sd = 0.1,
        sv_sd = 0.1,
        resid_sd = 0.05,
        sex_sd = 0.1,
        age_sd = 0.1
    ),
    ## Run each simulation 31 times with different seeds
    #tibble(seed = seq(from = 1986, length.out = 31))
    tibble(seed = seq(from = 1986, length.out = 10))
)
sim_param_names <- sort(unlist(sapply(grid_list, colnames)))
sim_table <- grid_list %>%
    Reduce(f = cross_join) %>%
    distinct %>%
    filter(!(handle_mislabels == "remove" & n_mislabels >= 2 * n_samples_per_group)) %>%
    arrange(seed)

## Comment this out later
sim_methods <- c("correct_entropy_comprehensive_with_remove_majority")
sim_table %<>% filter(handle_mislabels %in% sim_methods & n_mislabels < 90)
# sim_table %<>% filter(handle_mislabels == "correct_majority_cycles")
# sim_table %<>% filter(handle_mislabels == "correct_majority_cycles_swaps_entropy_with_remove_majority")
# sim_table %<>% filter(handle_mislabels != "correct_local_search_entropy") %>%
#    filter(!(handle_mislabels == "majority_cycles_swap_entropy_correct_and_remove" & n_mislabels > 30))

sim_table
```

# Run simulations

```{r}
make_param_string <- function(params) {
    params <- params[sort(names(params))]
    Map(str_c, names(params), "=", params) %>%
        c(sep = "|") %>%
        do.call(what = str_c)
}

if (file_exists("sim_results.qs")) {
    tsmsg("Reading saved simulation results")
    # Read the results file but filter/merge with current planned simulations
    sim_result_table <- sim_table %>% 
        left_join(qread("sim_results.qs", nthreads = availableCores())) %>%
        # Fill in any NULL entries with "not run yet" errors
        mutate(
            top_table = if_else(
                sapply(top_table, is.null), 
                list(try(stop("Simulation not run yet"), silent = TRUE)),
                top_table),
            label_outcomes = if_else(
                sapply(label_outcomes, is.null),
                list(try(stop("Simulation not run yet"), silent = TRUE)),
                label_outcomes)
        )
} else {
    sim_result_table <- sim_table %>%
        mutate(
            top_table = list(try(stop("Simulation not run yet"), silent = TRUE)),
            label_outcomes = list(try(stop("Simulation not run yet"), silent = TRUE))
        )
}

#plan(callr, workers=8)
plan(sequential)
need_to_run <- sapply(sim_result_table$top_table, is, "try-error")
if (any(need_to_run)) system.time({
    tsmsg("Running ", sum(need_to_run), " simulations")
    sim_result_table[need_to_run, ] %<>% 
        mutate(
            results_list = {
                map_args <- list(f = function(...) try(run_sim(...), silent = FALSE))
                map_args[sim_param_names] <- .[sim_param_names]
                do.call(future_Map, map_args)},
            top_table = lapply(results_list, \(x) try(x$tt, silent = FALSE)),
            label_outcomes = lapply(results_list, \(x) try(x$label_outcomes, silent = FALSE))
        ) %>% select(-results_list)
    need_to_run <- sapply(sim_result_table$top_table, is, "try-error")
    qsave(sim_result_table, "sim_results.qs", nthreads = availableCores())
    assert_that(!any(need_to_run))
})
```

# Collect simulation results

```{r}
fdr_threshold <- 0.05

sim_result_long_tt_table <- sim_result_table %>% 
    select(-label_outcomes) %>% 
    filter(sapply(top_table, is.data.frame)) %>%
    unnest(top_table) %>%
    mutate(
        ## All true logFC are >0, so negative logFC is a non-DE
        ## call for our purposes
        Called_DE = adj.P.Val <= fdr_threshold & logFC > 0,
        Feature_Call = case_when(
            DE & Called_DE ~ "TP",
            DE & !Called_DE ~ "FN",
            !DE & Called_DE ~ "FP",
            !DE & !Called_DE ~ "TN",
            .default = NA
        ) %>% factor(levels = c("TP", "TN", "FP", "FN"))
    )

sim_result_auc_table <- sim_result_long_tt_table %>% 
    filter(!is.na(DE) & !is.na(adj.P.Val)) %>%
    group_by(pick(all_of(sim_param_names))) %>% 
    summarise(
      # < param indicates that control is greater than case
      # Need to use t instead of adj.P.Val because adj.P.Val is direction-blind 
      # (after swapping n_samples_per_group times, you get back to a very low p-value)
      AUROC = as.numeric(roc(DE, t, levels=as.factor(c(FALSE, TRUE)), direction="<")$auc),
      .groups = "drop"
    )

sim_result_label_outcomes_table <- sim_result_table %>% 
    select(-top_table) %>% 
    filter(sapply(label_outcomes, is.data.frame)) %>% 
    unnest(label_outcomes) %>% 
    group_by(pick(all_of(sim_param_names)), Mislabeled_orig, Outcome) %>% 
    summarize( Num_Samples = n(), .groups = "drop" ) %>% 
    mutate(
        Mislabeled_orig = ifelse( Mislabeled_orig, "mislabels", "correct_labels" )
    ) %>% 
    pivot_wider(
        names_from = c("Mislabeled_orig", "Outcome"),
        values_from = "Num_Samples",
        values_fill = 0
    )
label_outcome_cols <- c("mislabels_correctly_relabeled", "mislabels_removed", "mislabels_incorrectly_relabeled", 
    "mislabels_ignored", "correct_labels_ignored", "correct_labels_incorrectly_relabeled", "correct_labels_removed")
missing_cols <- setdiff(label_outcome_cols, names(sim_result_label_outcomes_table))
if (length(missing_cols) != 0) {
    for (missing_col in missing_cols) {
        sim_result_label_outcomes_table[[missing_col]] <- 0
    }
}

sim_result_perf_table <- sim_result_long_tt_table %>%
    filter(!is.na(Feature_Call)) %>%
    group_by(pick(all_of(sim_param_names)), Feature_Call) %>%
    summarise(Num_Genes = n(), .groups = "drop") %>%
    pivot_wider(
        names_from = "Feature_Call",
        values_from = "Num_Genes",
        values_fill = 0
    ) %>%
    mutate(
        Recall = TP / (TP + FN),
        Specificity = TN / (TN + FP),
        Precision = TP / (TP + FP),
        NPV = TN / (TN + FN),
        FDR = FP / (FP + TP),
        Accuracy = (TP + TN) / n_features
    ) %>%
    full_join(sim_result_auc_table, by=sim_param_names, keep=FALSE) %>% 
    full_join(sim_result_label_outcomes_table, by=sim_param_names, keep=FALSE) %>% 
    mutate(
      Pct_Swapped = 100 * n_mislabels / (2 * n_samples_per_group),
      Swap_Type = swap_model
    )

sim_result_perf_summary_table <- sim_result_perf_table %>%
    group_by(pick(all_of(setdiff(sim_param_names, "seed")))) %>%
    summarise(
        N_sims = n(),
        across(
            c(FN, FP, TN, TP, Recall, Specificity, Precision, NPV, FDR, Accuracy, AUROC, 
              mislabels_correctly_relabeled, mislabels_removed, mislabels_incorrectly_relabeled, mislabels_ignored,
              correct_labels_ignored, correct_labels_incorrectly_relabeled, correct_labels_removed),
            c(
                mean = \(x) mean(x, na.rm = TRUE),
                sd = \(x) sd(x, na.rm = TRUE),
                median = \(x) median(x, na.rm = TRUE),
                ## Modify min and max functions so they return NA for empty lists
                ## Rather than Inf and -Inf
                min = function(x) {
                    val <- min(x, na.rim = TRUE)
                    if (is.infinite(val)) {
                        return(NA_real_)
                    }
                    return(val)
                },
                max = function(x) {
                    val <- max(x, na.rim = TRUE)
                    if (is.infinite(val)) {
                        return(NA_real_)
                    }
                    return(val)
                },
                se = function(x) {
                    x <- x[!is.na(x)]
                    if (length(x) == 0) { return(NA_real_) }
                    sd(x) / sqrt(length(x))
                }
            )
        ),
        .groups = "drop"
    ) %>%
    mutate(
        Pct_Swapped = 100 * n_mislabels / (2 * n_samples_per_group),
        Swap_Type = swap_model
    )

```

# Plot results

## Error bar plots

```{r fig.height=9, fig.width=12}
make_y_aes <- \(measure) aes_string(
    y = glue("{measure}_mean"),
    ymin = glue("{measure}_mean - {measure}_se"),
    ymax = glue("{measure}_mean + {measure}_se")
)
perf_names <- c("FN", "FP", "TN", "TP", "Recall", "Specificity", "Precision", "NPV", "FDR", "Accuracy", "AUROC")
perf_ylim_max <- if_else(perf_names %in% c("FN", "FP", "TN", "TP"), 300, 1) %>%
    set_names(perf_names)
p1 <- ggplot(sim_result_perf_summary_table) +
    aes(
        x = Pct_Swapped,
        color = handle_mislabels,
        fill = handle_mislabels,
        group = handle_mislabels
    ) +
    make_y_aes("Precision") +
    # geom_ribbon(alpha = 0.2, color = NA)`` + 
    geom_errorbar(
        width = 9,
        alpha = 0.8,
        position = position_dodge(width = 3)
    ) +
    geom_line(
        alpha = 0.5,
        position = position_dodge(width = 3)
    ) +
    geom_point(position = position_dodge2(width = 3), shape = 23) +
    facet_wrap("Swap_Type") + 
    labs(
        x = "Percent of samples mislabeled", 
        color = "How mislabels are handled",
        fill = "How mislabels are handled"
    ) + 
    scale_color_brewer(palette = "Set1") + 
    scale_fill_brewer(palette = "Set1")
perf_plots <- lapply(perf_names, \(pn) p1 + make_y_aes(pn) + ylim(0, perf_ylim_max[pn]) + ylab(glue("{pn}  Std. Err."))) %>%
    set_names(perf_names)

perf_include <- c("Recall", "Precision", "AUROC")
p <- wrap_plots(perf_plots[perf_include], ncol = 1, guides = "collect") & theme(legend.position = "top")
print(p)
with_pdf("sim_errbar.pdf", print(p), width = 8, height = 3 * length(perf_include))
```

## Boxplots

```{r fig.height=9, fig.width=12}

perf_boxplots <- lapply(
    perf_names,
    \(pn) ggplot(sim_result_perf_table %>% filter(n_mislabels %% 10 == 0)) +
        aes(
            x = Pct_Swapped,
            color = handle_mislabels,
            fill = handle_mislabels,
            group = handle_mislabels
        ) +
        aes_string(y = pn) +
        ylim(0, perf_ylim_max[pn]) +
        geom_boxplot(
            aes(group = interaction(Pct_Swapped, handle_mislabels, Swap_Type)),
            alpha = 0.2,
            position = position_dodge(width = 3)
        ) +
        # geom_line(
        #     aes_string(y = glue("{pn}_median")), data = sim_result_perf_summary_table,
        #     position = position_dodge(width = 3),
        #     alpha = 0.5
        # ) +
        facet_wrap("Swap_Type") + 
        labs(
            x = "Percent of samples mislabeled", 
            color = "How mislabels are handled",
            fill = "How mislabels are handled"
        ) + 
        scale_color_brewer(palette = "Set1") + 
        scale_fill_brewer(palette = "Set1") + 
        scale_x_continuous(breaks = seq(from = 0, to = 100, by = 20))
) %>%
    set_names(perf_names)

perf_include <- c("Recall", "Precision", "AUROC")
boxp <- wrap_plots(perf_boxplots[perf_include], ncol = 1, guides = "collect") & theme(legend.position = "top")
# Apparently R can't create files in PWD??? WTF?
with_pdf(fs::path(tempdir(), "sim_boxplot.pdf"), print(boxp), width = 8, height = 3 * length(perf_include))
file_move(fs::path(tempdir(), "sim_boxplot.pdf"), fs::path(getwd(), "sim_boxplot.pdf"))
#pdf(fs::path(getwd(), "sim_boxplot.pdf"), width = 8, height = 6)
print(boxp)
# dev.off()
# qsave(boxp, path(getwd(), "sim_boxplot.qs"))
```

## Label outcome plots

```{r fig.height=28, fig.width=12}

n_samples <- max(2*sim_result_perf_summary_table$n_samples_per_group, na.rm=TRUE)
mislabel_handlers_to_plot <- c("correct_entropy_comprehensive_with_remove_majority")
mislabels_perf_names <- c("mislabels_correctly_relabeled_mean", "mislabels_removed_mean", "mislabels_ignored_mean", "mislabels_incorrectly_relabeled_mean")
perf_names <- c(mislabels_perf_names, "correct_labels_removed_mean", "correct_labels_ignored_mean", "correct_labels_incorrectly_relabeled_mean")
perf_yx_slope <- if_else(perf_names %in% mislabels_perf_names, 1, -1) %>%
    set_names(perf_names)
perf_yx_intercept <- if_else(perf_names %in% mislabels_perf_names, 0, n_samples) %>%
    set_names(perf_names)
missing_mislabel_handlers <- setdiff(mislabel_handlers_to_plot, sim_result_perf_summary_table$handle_mislabels)
assert_that(
    length(missing_mislabel_handlers) == 0,
    msg = glue("Attempting to plot mislabel_handlers that were not part of simulation grid: {missing_mislabel_handlers}"))

p1 <- ggplot(sim_result_perf_summary_table %>% filter(handle_mislabels %in% mislabel_handlers_to_plot)) +
    aes(
        x = n_mislabels,
        y = mislabels_correctly_relabeled_mean,
        color = handle_mislabels,
        fill = handle_mislabels,
        group = handle_mislabels
    ) +
    geom_line(
        alpha = 0.5,
        position = position_dodge(width = 3)
    ) +
    geom_point(position = position_dodge2(width = 3), shape = 23) +
    facet_wrap("Swap_Type") + 
    labs(
        x = "Number of samples mislabeled", 
        color = "How mislabels are handled",
        fill = "How mislabels are handled"
    ) + 
    scale_color_brewer(palette = "Set1") + 
    scale_fill_brewer(palette = "Set1")

perf_plots <- lapply(perf_names, \(pn) p1 + aes_string(y=pn) + ylim(0, n_samples) + 
                         geom_abline(intercept = perf_yx_intercept[[pn]], slope = perf_yx_slope[[pn]], linetype = "dashed", color = "black")) %>%
    set_names(perf_names)

p <- wrap_plots(perf_plots, ncol = 1, guides = "collect") & theme(legend.position = "top")
print(p)
with_pdf("sim_labels.pdf", print(p), width = 12, height = 4 * length(perf_names))
```

# Analyses

```{r}

##########################################################################################
# How does the size of the largest connected component scale with the number of samples? #
##########################################################################################

grid_list <- list(
    tibble(pct_mislabels = seq(from=.10, to=.50, by=.10)),
    tibble(n_samples = seq(from=50, to=2000, by=50)),
    tibble(avg_samples_per_subject = seq(from=2, to=6, by=1)),
    ## Not varying any of these
    tibble(
        handle_mislabels = "ignore",
        swap_model = "random_with_replacement",
        n_features = 10,
        n_sv = 5,
        fraction_de_case = 0.5,
        case_sd = 0.1,
        subject_sd = 0.1,
        sv_sd = 0.1,
        resid_sd = 0.05,
        sex_sd = 0.1,
        age_sd = 0.1
    ),
    tibble(seed = seq(from = 1986, length.out = 10))
)

sim_table <- grid_list %>%
    Reduce(f = cross_join) %>%
    distinct %>%
    arrange(seed) %>% 
    mutate(
        n_samples_per_group = as.integer(n_samples/2),
        n_subjects_per_group = as.integer(n_samples_per_group/avg_samples_per_subject),
        n_mislabels = as.integer(n_samples * pct_mislabels)
    )

connected_component_distribution <- function(...) {
    elist <- sim_mislabeled_data(...)
    elist_graph <- generate_graph(elist, graph_type="combined")
    connected_components <- elist$targets[, c("Sample_ID", "Subject_ID", "Genotype_Group_ID")]
    connected_components$Component_ID <- clusters(elist_graph)$membership
    sample_tallies <- table(connected_components$Component_ID)
    results = list()
    results$largest_component_size <- max(sample_tallies)
    results$avg_component_size <- mean(sample_tallies)
    return(results)
}

required_args <- names(formals(sim_mislabeled_data))

sim_results_table <- sim_table %>% 
    mutate(
        results = {
            map_args <- list(f = function(...) try(connected_component_distribution(...), silent = FALSE))
            map_args[required_args] <- .[required_args]
            do.call(future_Map, map_args)}
    )

sim_results_table %<>% 
    mutate(
        largest_component_size = sapply(results, \(x) x$largest_component_size),
        avg_component_size = sapply(results, \(x) x$avg_component_size),
        )

sim_results_table_avg <- sim_results_table[seq(from=2, to=nrow(sim_results_table), by=2), ] %>% unnest(results)
sim_results_table_avg$avg_component_size <- sim_results_table_avg$results
sim_results_table_avg$pct_mislabels <- as.factor(sim_results_table_avg$pct_mislabels)
sim_summary_table_avg <- sim_results_table_avg %>%
    group_by(pick(all_of(setdiff(names(.), "seed")))) %>%
    summarise(
        avg_component_size = mean(avg_component_size))

sim_summary_table_max <- sim_results_table_max %>%
    group_by(pick(all_of(setdiff(names(.), "seed")))) %>%
    summarise(
        largest_component_size = mean(largest_component_size))

names(sim_results_table_max)

sim_summary_table_max <- sim_results_table_max %>%
    group_by(pick(all_of(setdiff(names(.), "seed")))) %>%
    summarise(
        largest_component_size = mean(largest_component_size))

sim_summary_table$pct_mislabels <- as.factor(sim_summary_table$pct_mislabels)

cc_plot <- ggplot(sim_summary_table) +
    aes(
        x = n_samples,
        y = largest_component_size,
        color = pct_mislabels,
        fill = pct_mislabels,
        group = pct_mislabels
    ) +
    geom_point(
        alpha = 0.5,
        position = position_dodge(width = 3)
    ) +
    geom_point(position = position_dodge2(width = 3), shape = 23) +
    facet_wrap("avg_samples_per_subject") + 
    labs(
        x = "Total number of samples", 
        color = "Pct mislabeled",
        fill = "Pct mislabeled"
    ) + 
    scale_color_brewer(palette = "Set1") + 
    scale_fill_brewer(palette = "Set1")

cc_plot_avg <- ggplot(sim_summary_table_avg) +
    aes(
        x = n_samples,
        y = avg_component_size,
        color = pct_mislabels,
        fill = pct_mislabels,
        group = pct_mislabels
    ) +
    geom_point(
        alpha = 0.5,
        position = position_dodge(width = 3)
    ) +
    geom_point(position = position_dodge2(width = 3), shape = 23) +
    facet_wrap("avg_samples_per_subject") + 
    labs(
        x = "Total number of samples", 
        color = "Pct mislabeled",
        fill = "Pct mislabeled"
    ) + 
    scale_color_brewer(palette = "Set1") + 
    scale_fill_brewer(palette = "Set1")

```


# Charles - playing around with code

## Debugging

```{r}

for (row in 1:nrow(sim_table[need_to_run, ])) {
    params <- as.list(sim_table[need_to_run, ][row, ])
    print(params)
    result <- do.call(run_sim, params) 
}

my_params <- as.list(sim_table[need_to_run, sim_param_names][1, ])
result <- do.call(run_sim, my_params)
elist_params <- my_params[names(my_params) != "handle_mislabels"]
elist <- do.call(sim_mislabeled_data, elist_params)

elist_params <- list(
  n_subjects_per_group = 15,
  n_samples_per_group = 60,
  n_features = 10,
  n_mislabels = 20,
  n_sv = 5,
  fraction_de_case = 0.5,
  case_sd = 0.1,
  subject_sd = 0.1,
  sex_sd = 0.1,
  age_sd = 0.1,
  sv_sd = 0.1,
  resid_sd = 0.05,
  swap_model = "random_with_replacement",
  seed = 1988)
elist <- do.call(sim_mislabeled_data, elist_params)
sample_genotype_data <- elist$targets %>% 
    select(Sample_ID, Subject_ID, Genotype_Group_ID) %>% 
    mutate(
        Init_Sample_ID = Sample_ID
    )
combined_graph <- generate_graph(sample_genotype_data, graph_type="combined")
sample_genotype_data$Component_ID <- clusters(combined_graph)$membership[sample_genotype_data$Sample_ID]





combined_graph <- generate_graph(sample_genotype_data, graph_type="combined")
elist <- mislabel_handlers$correct_majority_swaps(elist)
elist <- mislabel_handlers$correct_comprehensive_search(elist)
elist <- mislabel_handlers$correct_majority_cycles(elist)
elist <- mislabel_handlers$correct_majority_swaps(elist)
elist <- mislabel_handlers$correct_local_search_entropy(elist)
elist <- mislabel_handlers$correct_majority_cycles_with_remove_majority(elist)
elist <- mislabel_handlers$correct_majority_cycles_swaps_entropy_with_remove_majority(elist)

sim_params <- elist_params
sim_params$handle_mislabels <- "correct_majority_cycles_swaps_entropy_with_remove_majority"
results_list <- do.call(run_sim, sim_params)

results_list <- do.call(run_sim, c(my_params))

test_auc_conditions_list <- as.list(sim_result_long_table[1,sim_param_names])
test_auc_table <- sim_result_long_table %>% 
  filter(
      #all(sapply(names(test_auc_conditions_list), function(col) get(col) == test_auc_conditions_list[[col]]))
      age_sd == 0,
      case_sd == 10,
      fraction_de_case == 0.5,
      handle_mislabels == "ignore",
      n_features == 10000,
      n_samples_per_subject == 3,
      n_subjects_per_group == 50,
      n_sv == 5,
      n_swaps == 0,
      resid_sd == 0.05,
      seed == 1986,
      sex_sd == 0,
      sv_sd == 0,
      !swap_systematic
  )
```

```{r}

## DO NOT TOUCH THESE BELOW ##

## Case with 3C and 4C ambiguity that currently breaks the 
## iterative_majority algorithm (the ambiguity is not filtered out
## and you find 2 paths that return to the same head)
elist_params <- list(
  n_subjects_per_group = 2,
  n_samples_per_subject = 8,
  n_features = 5,
  n_mislabels = 5,
  n_sv = 5,
  fraction_de_case = 0.5,
  case_sd = 0.1,
  subject_sd = 0.1,
  sex_sd = 0.1,
  age_sd = 0.1,
  sv_sd = 0.1,
  resid_sd = 0.1,
  swap_model = "random_with_replacement",
  seed = 1990)
elist <- do.call(sim_mislabeled_data, elist_params)
elist <- mislabel_handlers$majority_cycles_correct(elist)

## Case where no majority can be formed in a subject, so any cycle
## that passes through that subject cannot be resolved
elist_params <- list(
  n_subjects_per_group = 30,
  n_samples_per_subject = 5,
  n_features = 5,
  n_mislabels = 60,
  n_sv = 5,
  fraction_de_case = 0.5,
  case_sd = 0.1,
  subject_sd = 0.1,
  sex_sd = 0.1,
  age_sd = 0.1,
  sv_sd = 0.1,
  resid_sd = 0.1,
  swap_model = "random_with_replacement",
  seed = 1989)
elist <- do.call(sim_mislabeled_data, elist_params)
elist <- mislabel_handlers$majority_cycles_correct(elist)

## Case with ambiguities
elist_params <- list(
  n_subjects_per_group = 30,
  n_samples_per_subject = 5,
  n_features = 5,
  n_mislabels = 60,
  n_sv = 5,
  fraction_de_case = 0.5,
  case_sd = 0.1,
  subject_sd = 0.1,
  sex_sd = 0.1,
  age_sd = 0.1,
  sv_sd = 0.1,
  resid_sd = 0.1,
  swap_model = "random_with_replacement",
  seed = 1988)
elist <- do.call(sim_mislabeled_data, elist_params)
elist <- mislabel_handlers$majority_cycles_correct(elist)

## This works
elist_params <- list(
  n_subjects_per_group = 10,
  n_samples_per_subject = 5,
  n_features = 5,
  n_mislabels = 30,
  n_sv = 5,
  fraction_de_case = 0.5,
  case_sd = 0.1,
  subject_sd = 0.1,
  sex_sd = 0.1,
  age_sd = 0.1,
  sv_sd = 0.1,
  resid_sd = 0.1,
  swap_model = "random_with_replacement",
  seed = 1990)
elist <- do.call(sim_mislabeled_data, elist_params)
elist <- mislabel_handlers$majority_cycles_correct(elist)

```

```{r}

library(node2vec)

lab_edges <- get.edgelist(generate_graph(elist, "label")) %>%
    as.data.frame() %>% 
    transmute(
        sample1 = gsub("_", "", V1),
        sample2 = gsub("_", "", V2)
    )
gen_edges <- get.edgelist(generate_graph(elist, "genotype")) %>%
    as.data.frame() %>% 
    transmute(
        sample1 = gsub("_", "", V1),
        sample2 = gsub("_", "", V2)
    )

lab_emb1 <- node2vecR(lab_edges, p=3, q=1, num_walks=10, walk_length=100, dim=2)
lab_emb2 <- node2vecR(lab_edges, p=3, q=1, num_walks=10, walk_length=100, dim=2)

lab_emb1 <- lab_emb1[order(rownames(lab_emb1)), ]
lab_emb2 <- lab_emb2[order(rownames(lab_emb2)), ]

gen_emb <- node2vecR(gen_graph_no_underscore)

lab_emb <- lab_emb1[order(rownames(lab_emb)), ]
gen_emb <- gen_emb1[order(rownames(gen_emb)), ]

emb<-node2vecR(gene_edges,p=2,q=1,num_walks=5,walk_length=5,dim=10)
```

```{r}



## Helper function for the majority-based label correction algorithms
## For each inferred mislabeled sample, find all potential relabels
get_potential_relabels_list_old <- function(elist) {
    elist <- populate_majorities(elist)
    inferred_mislabel_univ <- elist$targets %>% 
        filter(Non_Majority | is.na(Non_Majority)) %>% 
        ## Ambiguous samples w/ same subject_id label in the same genotype_group
        group_by(Subject_ID, E_Subject_ID) %>%
        filter(n() == 1) %>% 
        ungroup() %>% 
        pull(Sample_ID)
    
    potential_relabels_list <- list()
    for (sample_id in inferred_mislabel_univ) {
        majority_subject_id <- elist$targets[sample_id, ]$Majority_Subject_ID
        ## Don't actually need the E_Majority_Subject_ID, just the arbitrary genotype index
        e_subject_id <- elist$targets[sample_id, ]$E_Subject_ID
        ## If sample_id A1's genotype group has a consensus majority_subject_id B
        ## The potential_relabels are sample_ids B[#] that
        ##      1) have subject_id B (matching A1's majority_subject_id B)
        ##      2) are currently in a genotype group that is
        ##          i) different from A1's genotype group
        ##          ii) has fewer B-labeled samples than in A's genotype group
        if (!is.na(majority_subject_id)) {
            potential_relabels <- elist$targets %>% 
                filter(Subject_ID == majority_subject_id & E_Subject_ID != e_subject_id) %>% 
                pull(Sample_ID)
        ## If sample_id A's genotype group doesn't have a consensus majority_subject_id
        ## The potential_relabels are sample_ids B that satisfy
        ##      1) their subject_id would cast the deciding vote for a majority_subject_id in the genotype group for sample A
        ##      2) they are in a different genotype group than sample_id A
        } else {
            e_subject_id <- elist$targets[sample_id, ]$E_Subject_ID
            subject_id <- elist$targets[sample_id, ]$Subject_ID
            potential_relabels <- c()
            genotype_group <- elist$targets %>% 
                filter(E_Subject_ID == e_subject_id)
            n <- nrow(genotype_group)
            for (curr_subject_id in unique(genotype_group$Subject_ID)) {
                if (curr_subject_id == subject_id) { next }
                n_votes <- nrow(genotype_group %>% filter(Subject_ID == curr_subject_id))
                if ((n_votes + 1) / n > 0.5) {
                    curr_potential_relabels <- elist$targets %>% 
                        filter(Subject_ID == curr_subject_id & !(Sample_ID %in% genotype_group$Sample_ID)) %>% 
                        pull(Sample_ID)
                    potential_relabels <- c(potential_relabels, curr_potential_relabels)
                }
            }
        }
        potential_relabels_list[[sample_id]] <- potential_relabels
    }
    return(potential_relabels_list)
}

        # ## Case 2: There is no consensus majority_subject_id
        # else {
        #     e_subject_id <- votes[sample_id, ]$E_Subject_ID[[1]]
        #     subject_id <- votes[sample_id, ]$Subject_ID[[1]]
        #     potential_relabels <- c()
        #     genotype_group <- elist$targets %>% 
        #         filter(E_Subject_ID == e_subject_id)
        #     n <- nrow(genotype_group)
        #     for (curr_subject_id in unique(genotype_group$Subject_ID)) {
        #         if (curr_subject_id == subject_id) { next }
        #         n_votes <- nrow(genotype_group %>% filter(Subject_ID == curr_subject_id))
        #         if ((n_votes + 1) / n > 0.5) {
        #             curr_potential_relabels <- elist$targets %>% 
        #                 filter(Subject_ID == curr_subject_id & !(Sample_ID %in% genotype_group$Sample_ID)) %>% 
        #                 pull(Sample_ID)
        #             potential_relabels <- c(potential_relabels, curr_potential_relabels)
        #         }
        #     }
        # }
        

## Helper function for the majority-based label correction algorithms
## For each inferred mislabeled sample, find all potential relabels
get_majority_relabels_graph <- function(elist) {
    votes <- genotype_group_vote(elist)
    ## For each genotype group, the potential subject_ids are those that are one vote away from achieving a majority
    vote_cols <- unique(votes$Subject_ID)
    potential_subject_ids <- (votes[, vote_cols] + 1 > votes$n_votes/2) & (votes[, vote_cols] >= 1)
    inferred_mislabel_univ <- votes %>% 
        filter(Non_Majority | is.na(Non_Majority)) %>% 
        ## Samples w/ same subject_id label in the same genotype_group are ambiguous and so we filter them away
        group_by(Subject_ID, Genotype_Group_ID) %>%
        filter(n() == 1) %>% 
        ungroup() %>% 
        pull(Sample_ID)
    
    ## The potential relabels for sample_id A[#] (in genotype group i) are 
    ## sample_ids B[#] (in genotype group j) satisfying
    ##      1) Group i's majority_subject_id is B, or one additional vote for B would be the deciding majority vote
    ##      2) Group i and j are different genotype groups
    ##      3) Group j has fewer votes for subject_id B than Group i
    potential_relabels_list <- list()
    for (sample_id in inferred_mislabel_univ) {
        potential_relabels <- NULL
        Genotype_Group_ID <- votes[sample_id, ]$Genotype_Group_ID[[1]]
        subject_id <- votes[sample_id, ]$Subject_ID[[1]]
        majority_subject_ids <- colnames(potential_subject_ids)[potential_subject_ids[sample_id, ]]
        n_votes_i_list <- votes[sample_id, majority_subject_ids, drop=FALSE]
        if (!is.null(majority_subject_ids)) {
            potential_relabels <- votes %>% 
                filter(
                    Subject_ID %in% majority_subject_ids,
                    Subject_ID != subject_id,
                    Genotype_Group_ID != Genotype_Group_ID) %>% 
                rowwise() %>% 
                mutate(
                    n_votes_j = get(Subject_ID),
                    n_votes_i = n_votes_i_list[[Subject_ID]]
                ) %>% 
                ungroup() %>% 
                filter(n_votes_j < n_votes_i) %>% 
                pull(Sample_ID)
        }
        potential_relabels_list[[sample_id]] <- potential_relabels
    }
    return(potential_relabels_list)
}

generate_relabels_graph <- function(connected_component, assumed_subjects) {
    assert_that(all(unique(connected_component$Genotype_Group_ID) %in% names(assumed_subjects)), 
                msg="Connected component contained Genotype_Group_IDs not specified in assumed_subjects")
    connected_component_solver <- connected_component %>% 
        mutate(
            Assumed_Subject_ID = sapply(connected_component$Genotype_Group_ID, \(x) assumed_subjects[[x]]),
            Assumed_Mislabeled = Subject_ID != Assumed_Subject_ID
        )
    assumed_mislabels <- connected_component_solver %>% filter(Assumed_Mislabeled) %>% pull(Sample_ID)
    relabels_adj_matrix <- matrix(FALSE, nrow=length(assumed_mislabels), length(assumed_mislabels))
    rownames(relabels_adj_matrix) <- assumed_mislabels
    colnames(relabels_adj_matrix) <- assumed_mislabels
    for (sample_id in assumed_mislabels) {
        assumed_subject_id <- connected_component_solver[sample_id, ]$Assumed_Subject_ID[[1]]
        possible_relabels <- connected_component_solver %>% 
            filter(
                Sample_ID %in% assumed_mislabels,
                Subject_ID == assumed_subject_id
            ) %>% 
            pull(Sample_ID)
        relabels_adj_matrix[sample_id, possible_relabels] = TRUE
    }
    relabels_graph <- graph_from_adjacency_matrix(relabels_adj_matrix, mode="directed")
}

generate_relabels_permutation <- function(connected_component, assumed_subjects) {
    assert_that(all(unique(connected_component$Genotype_Group_ID) %in% names(assumed_subjects)), 
                msg="Connected component contained Genotype_Group_IDs not specified in assumed_subjects")
    connected_component_solver <- connected_component %>% 
        mutate(
            Assumed_Subject_ID = sapply(connected_component$Genotype_Group_ID, \(x) assumed_subjects[[x]]),
            Assumed_Mislabeled = Subject_ID != Assumed_Subject_ID
        )
    assumed_mislabels <- connected_component_solver[connected_component_solver$Assumed_Mislabeled, "Sample_ID"]
    potential_relabels_list <- list()
    for (i in seq_along(assumed_mislabels)) {
        sample_id <- assumed_mislabels[i]
        assumed_subject_id <- connected_component_solver[sample_id, ]$Assumed_Subject_ID[[1]]
        potential_relabels <- connected_component_solver %>% 
            filter(
                Sample_ID %in% assumed_mislabels,
                Subject_ID == assumed_subject_id
            ) %>% 
            pull(Sample_ID)
        potential_relabels_list[[i]] <- tibble(!!sample_id := potential_relabels)
    }
    potential_relabels <- as.matrix(potential_relabels_list %>% 
        Reduce(f = cross_join))
    is_permutation <- 
        unique()
        
    group_by_at(group_col) %>%
        mutate(
            sample_a = Sample_ID,
            sample_b = list(Sample_ID)
        ) %>%
        ungroup()
    # 
    #     Reduce(f = cross_join) %>%
    # distinct %>%
}

generate_relabels_permutation <- function(connected_component, assumed_subjects) {
    assert_that(all(unique(connected_component$Genotype_Group_ID) %in% names(assumed_subjects)), 
                msg="Connected component contained Genotype_Group_IDs not specified in assumed_subjects")
    connected_component_solver <- connected_component %>% 
        mutate(
            Assumed_Subject_ID = sapply(connected_component$Genotype_Group_ID, \(x) assumed_subjects[[x]]),
            Assumed_Mislabeled = Subject_ID != Assumed_Subject_ID
        )
    assumed_mislabels <- connected_component_solver[connected_component_solver$Assumed_Mislabeled, "Sample_ID"]
    potential_relabels_list <- list()
    for (i in seq_along(assumed_mislabels)) {
        sample_id <- assumed_mislabels[i]
        assumed_subject_id <- connected_component_solver[sample_id, ]$Assumed_Subject_ID[[1]]
        potential_relabels <- connected_component_solver %>% 
            filter(
                Sample_ID %in% assumed_mislabels,
                Subject_ID == assumed_subject_id
            ) %>% 
            pull(Sample_ID)
        potential_relabels_list[[i]] <- tibble(!!sample_id := potential_relabels)
    }
    potential_relabels <- as.matrix(potential_relabels_list %>% 
        Reduce(f = cross_join))
    is_permutation <- 
        unique()
        
    group_by_at(group_col) %>%
        mutate(
            sample_a = Sample_ID,
            sample_b = list(Sample_ID)
        ) %>%
        ungroup()
    # 
    #     Reduce(f = cross_join) %>%
    # distinct %>%
}

generate_relabels_permutation <- function(connected_component, assumed_subjects) {
    assert_that(all(unique(connected_component$Genotype_Group_ID) %in% names(assumed_subjects)), 
                msg="Connected component contained Genotype_Group_IDs not specified in assumed_subjects")
    connected_component_solver <- connected_component %>% 
        mutate(
            Assumed_Subject_ID = sapply(connected_component$Genotype_Group_ID, \(x) assumed_subjects[[x]]),
            Assumed_Mislabeled = Subject_ID != Assumed_Subject_ID
        )
    relabels_adj_matrix <- matrix(FALSE, nrow=length(assumed_mislabels), length(assumed_mislabels))
    rownames(relabels_adj_matrix) <- assumed_mislabels
    colnames(relabels_adj_matrix) <- assumed_mislabels
    for (sample_id in assumed_mislabels) {
        assumed_subject_id <- connected_component_solver[sample_id, ]$Assumed_Subject_ID[[1]]
        possible_relabels <- connected_component_solver %>% 
            filter(
                Sample_ID %in% assumed_mislabels,
                Subject_ID == assumed_subject_id
            ) %>% 
            pull(Sample_ID)
        relabels_adj_matrix[sample_id, possible_relabels] = TRUE
    }
    relabels_last_step <- t(relabels_adj_matrix)
    relabels_last_step[!relabels_last_step] = Inf
    relabels_graph <- graph_from_adjacency_matrix(relabels_adj_matrix, mode="directed")
    cycle_distances <- distances(relabels_graph, mode="out") * relabels_last_step
    
    Genotype_Group_IDs <- unique(connected_component_solver$Genotype_Group_ID)
    for (Genotype_Group_ID in Genotype_Group_IDs) {
        potential_relabels <- connected_component_solver %>% 
            filter(
                Assumed_Mislabeled,
                Subject_ID == assumed_subjects[[Genotype_Group_ID]]
            ) %>% 
            pull(Sample_ID)
        connected_component_solver[connected_component_solver$Genotype_Group_ID == Genotype_Group_ID
            & connected_component_solver$Assumed_Mislabeled, ]$Relabel <- sample(potential_relabels)
    }
    
    ## Make cycles smaller by detecting when you have 2 samples from same genotype group in same cycle
    assumed_mislabels <- connected_component_solver[connected_component_solver$Assumed_Mislabeled, "Sample_ID"]
    permutes_list <- list()
    for (i in seq_along(assumed_mislabels)) {
        sample_id <- assumed_mislabels[i]
        assumed_subject_id <- connected_component_solver[sample_id, ]$Assumed_Subject_ID[[1]]
        potential_relabels <- connected_component_solver %>% 
            filter(
                Sample_ID %in% assumed_mislabels,
                Subject_ID == assumed_subject_id
            ) %>% 
            pull(Sample_ID)
        potential_relabels_list[[i]] <- tibble(!!sample_id := potential_relabels)
    }
    
}

objective_genotype_entropy <- function(sample_genotype_data, neighbors) {

    
    calc_swapped_entropy = function(sample_genotype_data, swap_from, swap_to) {
        filtered_genotypes <- sample_genotype_data %>%
            filter(Sample_ID %in% c(swap_from, swap_to)) %>%
            pull(Genotype_Group_ID)
        filtered_labels <- sample_genotype_data %>% 
            filter(Genotype_Group_ID %in% filtered_genotypes)
        swap_from_genotype <- filtered_labels[[swap_from, "Genotype_Group_ID"]]
        swap_to_genotype <- filtered_labels[[swap_to, "Genotype_Group_ID"]]
        swapped_labels <- filtered_labels
        swapped_labels[swap_from, "Genotype_Group_ID"] <- swap_to_genotype
        swapped_labels[swap_to, "Genotype_Group_ID"] <- swap_from_genotype
        return(calc_entropy(swapped_labels) - calc_entropy(filtered_labels))
    }
    
    neighbors %<>% mutate(
        base = calc_entropy(sample_genotype_data),
        delta = mapply(calc_delta_entropy, swap_from=Sample_A, swap_to=Sample_B),
        objective = base + delta
    )
    return(neighbors)
}

objective_hamming_distance <- function(sample_genotype_data, neighbors) {
    calc_hamming_distance <- function(sample_genotype_data) {
        labels_graph <- generate_graph(sample_genotype_data, "label")
        genotype_graph <- generate_graph(sample_genotype_data, "genotype")
        int_graph <- graph.intersection(labels_graph, genotype_graph)
        return(ecount(labels_graph) + ecount(genotype_graph) - 2*ecount(int_graph))
    }
    
    calc_swapped_hamming_distance <- function(swap_from, swap_to) {
        swaps <- data.frame(relabel_from=c(swap_from), relabel_to=c(relabel_to))
        new_sample_genotype_data <- relabel_sample_genotype_data(sample_genotype_data, relabels)
        return(calc_hamming_distance(new_sample_genotype_data))
    }
    
    neighbors %<>% mutate(
        base = calc_hamming_distance(sample_genotype_data),
        objective = mapply(calc_swapped_hamming_distance, swap_from=Sample_A, swap_to=Sample_B),
        delta = objective - base
    )
    return(neighbors)
}

```